#!/bin/bash
set -e

# --- CONFIGURATION ---
BASE_DIR="$HOME/.bpf-trust"
KEY_DIR="$BASE_DIR/keys"
CONFIG_FILE="$BASE_DIR/config"

PRIV_KEY="$KEY_DIR/signing_key.pem"
DER_KEY="$KEY_DIR/signing_key.der"

# The C Tool (Assumed to be in CWD)
C_TOOL_NAME="setxattr"
C_TOOL_BIN="/home/kpsingh/projects/bpf-verity-gate/$C_TOOL_NAME"

# --- OPENSSL CONFIG ---
read -r -d '' OPENSSL_CONF << EOM || true
[ req ]
default_bits = 2048
distinguished_name = req_distinguished_name
prompt = no
string_mask = utf8only
x509_extensions = myexts

[ req_distinguished_name ]
CN = eBPF Signature Verification Testing Key

[ myexts ]
basicConstraints=critical,CA:FALSE
keyUsage=digitalSignature
subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid
EOM

# --- LOAD USER CONFIG ---
if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE"
fi

# --- SSH HELPERS ---
SSH_OPTS="-p ${BPF_VM_PORT:-22} -o StrictHostKeyChecking=no"
if [[ -n "$BPF_VM_KEY" ]]; then
    SSH_OPTS="$SSH_OPTS -i $BPF_VM_KEY"
fi

ensure_env() {
    mkdir -p "$KEY_DIR"

    # 2. Generate Keys if missing
    if [[ ! -f "$PRIV_KEY" || ! -f "$DER_KEY" ]]; then
        echo "[INFO] Generating keys..."
        local GENKEY_FILE="$KEY_DIR/x509.genkey"
        echo "$OPENSSL_CONF" > "$GENKEY_FILE"
        openssl req -new -nodes -utf8 -sha256 -days 36500 \
            -batch -x509 -config "$GENKEY_FILE" \
            -outform PEM -out "$PRIV_KEY" \
            -keyout "$PRIV_KEY" 2>/dev/null
        openssl x509 -in "$PRIV_KEY" -out "$DER_KEY" -outform der
        chmod 600 "$PRIV_KEY"
        rm "$GENKEY_FILE"
    fi
}

cmd_init() {
    rm -rf "$KEY_DIR"
    ensure_env
    echo "[OK] Initialized."
}

cmd_inject_public_key() {
    ensure_env
    echo "[INFO] Copying key to live VM..."
    scp $SSH_OPTS "$DER_KEY" "${BPF_VM_USER}@${BPF_VM_HOST}:/etc/pki/bpf-trust/verification_key.der"
}

cmd_sign() {
    local FILE="$1"
    [[ -f "$FILE" ]] || { echo "File not found: $FILE"; exit 1; }
    ensure_env

    echo "[INFO] Signing $FILE..."
    # 1. Generate Raw Binary Signature (.sig)
    fsverity sign --key "$PRIV_KEY" "$FILE" "${FILE}.sig" > /dev/null
    "$C_TOOL_BIN" "$FILE" "${FILE}.sig"
}

cmd_deploy() {
    local FILE="$1"
    local SIG_FILE="${FILE}.sig"

    if [[ ! -f "$SIG_FILE" ]]; then
        echo "[ERROR] Missing signature file: $SIG_FILE. Run 'sign' first."
        exit 1
    fi

    ensure_env

    local DEST="${BPF_VM_USER}@${BPF_VM_HOST}:${BPF_VM_DEST_DIR}"
    local REMOTE_FILE="${BPF_VM_DEST_DIR%/}/$(basename "$FILE")"
    local REMOTE_SIG="${BPF_VM_DEST_DIR%/}/$(basename "$SIG_FILE")"
    local REMOTE_TOOL="${BPF_VM_DEST_DIR%/}/$C_TOOL_NAME"

    echo "[INFO] Deploying artifacts..."

    rsync -avXz -e "ssh $SSH_OPTS" "$FILE" "$SIG_FILE" "$DEST"

    echo "[INFO] Sealing on VM..."
    ssh $SSH_OPTS "${BPF_VM_USER}@${BPF_VM_HOST}" fsverity enable $REMOTE_FILE --signature $REMOTE_SIG
    echo "[OK] Deployed and Sealed."
}

case "$1" in
    init) cmd_init ;;
    inject-public-key) cmd_inject_public_key "$2" ;;
    sign) cmd_sign "$2" ;;
    deploy) cmd_deploy "$2" ;;
    *) echo "Usage: $0 {init|inject-public-key|sign|deploy}"; exit 1 ;;
esac